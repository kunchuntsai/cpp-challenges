# Top 3 LeetCode Problems by Category - Neetcode 75

## Table of Contents
1. [Arrays & Hashing](#01-arrays--hashing)
2. [Two Pointers](#02-two-pointers)
3. [Sliding Window](#03-sliding-window)
4. [Stack](#04-stack)
5. [Binary Search](#05-binary-search)
6. [Linked List](#06-linked-list)
7. [Trees](#07-trees)
8. [Heap / Priority Queue](#08-heap--priority-queue)
9. [Backtracking](#09-backtracking)
10. [Tries](#10-tries)
11. [Graphs](#11-graphs)
12. [Advanced Graphs](#12-advanced-graphs)
13. [1-D Dynamic Programming](#13-1-d-dynamic-programming)
14. [2-D Dynamic Programming](#14-2-d-dynamic-programming)
15. [Greedy](#15-greedy)
16. [Intervals](#16-intervals)
17. [Math & Geometry](#17-math--geometry)
18. [Bit Manipulation](#18-bit-manipulation)

## 01. Arrays & Hashing
1. **Product of Array Except Self** (Medium) - Tests understanding of prefix/suffix products without division, O(1) extra space optimization
2. **Group Anagrams** (Medium) - String sorting and grouping, tests hash map usage with complex keys
3. **Top K Frequent Elements** (Medium) - Hash map + heap/bucket sort, combines multiple data structures

## 02. Two Pointers
1. **Valid Palindrome** (Easy) - Basic two-pointer technique, string processing fundamentals
2. **Two Sum II - Input Array Is Sorted** (Medium) - Classic sorted array two-pointer approach
3. **3Sum** (Medium) - Advanced two-pointer with outer loop, handles duplicates and edge cases

## 03. Sliding Window
1. **Best Time to Buy and Sell Stock** (Easy) - Single pass sliding window, foundational DP alternative
2. **Longest Substring Without Repeating Characters** (Medium) - Variable window with hash set
3. **Minimum Window Substring** (Hard) - Complex sliding window with character frequency tracking

## 04. Stack
1. **Valid Parentheses** (Easy) - Classic stack application, bracket matching fundamentals
2. **Min Stack** (Medium) - Stack with additional functionality, tests design thinking
3. **Daily Temperatures** (Medium) - Monotonic stack pattern, next greater element variant

## 05. Binary Search
1. **Binary Search** (Easy) - Pure binary search implementation, must-know template
2. **Search in Rotated Sorted Array** (Medium) - Modified binary search, tests edge case handling
3. **Find Minimum in Rotated Sorted Array** (Medium) - Binary search on rotated array, optimization thinking

## 06. Linked List
1. **Reverse Linked List** (Easy) - Fundamental linked list manipulation, iterative and recursive solutions
2. **Merge Two Sorted Lists** (Easy) - Basic linked list merging, pointer manipulation practice
3. **Linked List Cycle** (Easy) - Floyd's cycle detection algorithm, two-pointer technique on linked lists

## 07. Trees
1. **Invert Binary Tree** (Easy) - Basic tree traversal and manipulation, recursive thinking
2. **Maximum Depth of Binary Tree** (Easy) - Tree traversal fundamentals, DFS/BFS introduction
3. **Validate Binary Search Tree** (Medium) - BST properties, in-order traversal or bounds checking

## 08. Heap / Priority Queue
1. **Kth Largest Element in an Array** (Medium) - Min heap usage, heap size management
2. **Find Median from Data Stream** (Hard) - Two heaps technique, dynamic median maintenance
3. **Merge k Sorted Lists** (Hard) - Heap with custom comparator, efficient merging strategy

## 09. Backtracking
1. **Subsets** (Medium) - Basic backtracking template, subset generation pattern
2. **Combination Sum** (Medium) - Backtracking with repetition allowed, pruning techniques
3. **Word Search** (Medium) - 2D grid backtracking, path tracking and restoration

## 10. Tries
1. **Implement Trie (Prefix Tree)** (Medium) - Trie data structure implementation, insert/search/startsWith
2. **Word Search II** (Hard) - Trie + backtracking combination, complex optimization problem
3. **Design Add and Search Words Data Structure** (Medium) - Trie with wildcard search, DFS in trie

## 11. Graphs
1. **Number of Islands** (Medium) - Basic DFS/BFS on 2D grid, connected components
2. **Clone Graph** (Medium) - Graph traversal with node creation, handles cycles
3. **Course Schedule** (Medium) - Topological sort, cycle detection in directed graph

## 12. Advanced Graphs
1. **Network Delay Time** (Medium) - Dijkstra's algorithm, shortest path in weighted graph
2. **Cheapest Flights Within K Stops** (Medium) - Modified shortest path with constraints
3. **Alien Dictionary** (Hard) - Topological sort with custom ordering, string processing

## 13. 1-D Dynamic Programming
1. **Climbing Stairs** (Easy) - Basic DP introduction, Fibonacci-like recurrence
2. **House Robber** (Medium) - Linear DP with non-adjacent constraint
3. **Longest Increasing Subsequence** (Medium) - Classic DP problem, O(nÂ²) and O(n log n) solutions

## 14. 2-D Dynamic Programming
1. **Unique Paths** (Medium) - Grid DP fundamentals, combinatorics alternative
2. **Longest Common Subsequence** (Medium) - Classic 2D DP, string comparison problem
3. **Coin Change 2** (Medium) - Unbounded knapsack variant, counting combinations

## 15. Greedy
1. **Maximum Subarray** (Easy) - Kadane's algorithm, local vs global optimization
2. **Jump Game** (Medium) - Greedy choice property, reachability problem
3. **Gas Station** (Medium) - Circular array greedy, balance tracking

## 16. Intervals
1. **Merge Intervals** (Medium) - Interval merging, sorting and overlap detection
2. **Insert Interval** (Medium) - Interval insertion without sorting, in-place merging
3. **Non-overlapping Intervals** (Medium) - Interval scheduling, greedy approach

## 17. Math & Geometry
1. **Rotate Image** (Medium) - Matrix rotation in-place, layer-by-layer approach
2. **Spiral Matrix** (Medium) - Matrix traversal in spiral order, boundary management
3. **Set Matrix Zeroes** (Medium) - In-place matrix modification, space optimization

## 18. Bit Manipulation
1. **Single Number** (Easy) - XOR properties, finding unique element
2. **Number of 1 Bits** (Easy) - Bit counting, Brian Kernighan's algorithm
3. **Counting Bits** (Medium) - DP with bit manipulation, pattern recognition

---

## Why These Problems?

Each selected problem represents:
- **Fundamental patterns** that appear frequently in interviews
- **Progressive difficulty** within each category
- **Core algorithms** that build foundation knowledge
- **High frequency** in actual coding interviews at major tech companies

Focus on understanding the underlying patterns and techniques rather than memorizing solutions. These problems will give you a solid foundation for tackling similar challenges in interviews.